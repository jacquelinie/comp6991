# RSheets Mark Request

# Marked Questions

These questions are listed in the spec, and you must fill them out
to receive marks for the Design Questions.

## Question 1:
1. It is worse because parsing the user input string without the struct of Command would reduce readability and make error handling less manageable. A struct can neatly encapsulate the command structure. It also allows validation at the struct level, enabling type-safe access to fields.
2. It is worse because FromStr is a Rust idiom for converting strings into structured data types. FromStr aligns with standard Rust practice and allows the use of str::parse for parsing. A parse function would achieve similar functionality but lose the easy syntax for use and expressiveness that FromStr provides.
3. Worse because using named fields within an enum keeps all command-related logic in one file. Having GetCommand and SetCommand structs would require a more complicated control flow to handle each command type separately, making the code less concise.


## Question 2:
Scalar: value = CellArgument::Value(get_value(&var, cells));
Vector: value = get_vector(coords, cells, new_dependers);
Matrix: value = get_matrix(coords, cells, new_dependers);

All three types share similar logic in parse_expr_args and get_value functions to retrieve and parse the cell references.
There is distinct logic for each type, where in get_vector and get_matrix functions, there is different indexing to traverse the vector/matrix. There is also different return types.

Improvement: To consolidate handling further, a general function that accepts coordinates and returns either a Scalar, Vector, or Matrix based on parameters, could be used to reduce duplicate code. Maybe a while loop that can be used to traverse both the rows/columns can be used.

Changes:
- Add a MatrixList to CellArgument.
- Define a new function get_matrix_list that iterates over a list of matrix ranges and uses get_matrix to get matrices, storing each as a nested Vec<Vec<CellValue>>.
- Update parse_expr_args to recognize and handle MatrixList expressions.


## Question 3:



## Question 4:



## Question 5:
Set A1 5 sets A1 as 5 after being evaluated (1). The cell expression to evaluate A1 is set in the hashmap exprs as A1: 5 (2). Set B1 A1 evaluates A1 and sets B1 as 5 (3). It then adds A1 to the HashSet of B1 in the dependers HashMap to show that B1 depends on A1 (4). In the dependencies HashMap, B1 is added to A1’s HashSet.
Similarly for Set C1 B1, the same steps are taken. Set A1 7 sets A1 as 7 after evaluation (5), then when processing the dependencies, it sees that B1 is dependent on A1. I then evaluate the new B1 (6), then update B1’s dependencies (7). When updating, I check for what depends on B1- C1. We then reevaluate C1 (8), and check if anything is dependent on C1.
Finally get C1, I first check if C1 is a CellExprEvalError (9), otherwise it returns the CellValue (10).

Q5 CODE LINES:


# Questions to the Marker (OPTIONAL)

Remember: you don't have to fill these out; but if
you want to get feedback on a particular element of
your code; you can!

1.

2.

3.
